// Copyright (c) Blockforo
// SPDX-License-Identifier: BUSL-1.1

//go:build linux

package keyring

import (
	"fmt"
	"math/big"
	"strconv"
	"strings"
	"syscall"

	"golang.org/x/sys/unix"
)

// =================================================================
// User Key operations

// addKey adds a new key to the specific keyring
// If a key of the same type and description as that proposed already exists in the keyring,
// this will try to update it with the given payload, or it will return error EEXIST if that function is
// not supported by the key type.
// The process must also have permission to write to the key to be able to update it.
// The new key will have all user permissions granted and no group or third party permissions.
//
// Otherwise, this will attempt to create a new key of the specified type and description,
// and to instantiate it with the supplied payload and attach it to the keyring. In this case,
// an error will be generated if the process does not have permission to write to the keyring.
//
// If the key type supports it, if the description is NULL or an empty string,
// the key type will try and generate a description from the content of the payload.
//
// The payload is optional, and the pointer can be NULL if not required by the type.
// The payload is plen in size, and plen can be zero for an empty payload.
//
// A new keyring can be generated by setting type “keyring”, the keyring name as the description
// (or NULL) and setting the payload to NULL.
//
// User defined keys can be created by specifying type “user”.
// It is recommended that a user defined key’s description by prefixed with a type ID and a colon,
// such as “krb5tgt:” for a Kerberos 5 ticket granting ticket.
//
// Any other type must have been registered with the kernel in advance by a kernel service such as a filesystem.
//
// The ID of the new or updated key is returned if successful.
func addKey(name string, key []byte, keyringId Serial) (Serial, error) {
	id, err := unix.AddKey(KEY_TYPE_USER, name, key, keyringId.Int())

	// Convert the error
	err = fromErr(err)

	return Serial(id), err
}

// getKey reads the payload data from a key:
// This function attempts to read the payload data from the specified key into the buffer.
// The process must have read permission on the key to succeed.
//
// The returned data will be processed for presentation by the key type.
// For instance, a keyring will return an array of key_serial_t entries representing the IDs of all the keys to which it is subscribed.
// The user defined key type will return its data as is.
// If a key type does not implement this function, error EOPNOTSUPP will result.
//
// If the specified buffer is too small, then the size of the buffer required will be returned.
// Note that in this case, the contents of the buffer may have been overwritten in some undefined way.
//
// Otherwise, on success, the function will return the amount of data copied into the buffer.
func getKey(id Serial) ([]byte, error) {

	var buffer []byte

	for {
		length, err := unix.KeyctlBuffer(unix.KEYCTL_READ, int(id), buffer, 0)
		if err != nil {
			// Convert the error
			err = fromErr(err)

			return nil, err
		}

		// Return the buffer if it was large enough
		if length <= len(buffer) {
			return buffer[:length], nil
		}

		// Next try with a larger buffer
		buffer = make([]byte, length)
	}
}

// getKeyId returns the key unique id from the specific key ring
// This searches the keyring tree headed by the specified keyring until a key is found that matches the type and description criteria.
// Each keyring is checked for keys before recursion into its children occurs.
//
// The process must have search permission on the top level keyring, or else error EACCES will result.
//
// Only keyrings that the process has search permission on will be recursed into,
// and only keys and keyrings for which a process has search permission can be matched.
// If the specified keyring is not a keyring, ENOTDIR will result.
//
// If the search succeeds, the function will attempt to link the found key into the destination keyring
// if one is supplied (non-zero ID).
// All the constraints applicable to KEYCTL_LINK apply in this case too.
// Error ENOKEY, EKEYREVOKED or EKEYEXPIRED will be returned if the search fails.
// On success, the resulting key ID will be returned.
func getKeyId(name string, keyringId Serial) (Serial, error) {
	key, err := unix.KeyctlSearch(keyringId.Int(), KEY_TYPE_USER, name, 0)

	// Convert the error
	err = fromErr(err)

	return Serial(key), err
}

// deleteKeyWithName removes a key from the specific keyring by searching it via the name
func deleteKeyWithName(name string, keyringId Serial) error {

	// Find the existing key
	keyId, err := getKeyId(name, keyringId)

	// Handle the error
	if err != nil {
		// Convert the error
		err = fromErr(err)

		return err
	}

	// Delete the key
	return deleteKey(keyId, keyringId)
}

// deleteKey removes a key from the specific keyring
// This function looks through the keyring for the first link to the specified key, and removes it if found.
// Subsequent links to that key are ignored.
// The process must have write permission on the keyring.
// If the keyring is not a keyring, error ENOTDIR will result;
// and if the key is not present, error ENOENT will be the result.
func deleteKey(keyId Serial, keyringId Serial) error {

	// Delete the key
	_, _, errno := syscall.Syscall(syscall.SYS_KEYCTL, uintptr(unix.KEYCTL_INVALIDATE), uintptr(keyId.Int()), 0)

	if errno != 0 {
		// Convert the error
		err := fromErr(errno)
		return err
	}

	return nil
}

// =================================================================
// Link two keys
func link(child, parent Serial) error {
	_, _, errno := syscall.Syscall(syscall.SYS_KEYCTL, uintptr(unix.KEYCTL_LINK), uintptr(child.Int()), uintptr(parent.Int()))
	if errno != 0 {
		err := fromErr(errno)
		return err
	}

	return nil
}

// Un-Link two keys
func unlink(child, parent Serial) error {
	_, _, errno := syscall.Syscall(syscall.SYS_KEYCTL, uintptr(unix.KEYCTL_UNLINK), uintptr(child.Int()), uintptr(parent.Int()))
	if errno != 0 {
		err := fromErr(errno)
		return err
	}
	return nil
}

// Describe the key
func describe(id Serial) (KeyMetadata, error) {
	var meta KeyMetadata
	// Get the description
	description, err := unix.KeyctlString(unix.KEYCTL_DESCRIBE, id.Int())
	if err != nil {
		return meta, err
	}

	// Split it by `;`
	fields := strings.Split(description, ";")
	if len(fields) == 0 {
		return meta, fmt.Errorf("empty metadata")
	}

	names := []string{"type", "uid", "gid", "perm", "name"}
	metadata := make(map[string]string, len(fields))

	// Make sure we don't have a
	total := min(len(fields), len(names))

	for index := 0; index < total; index++ {
		metadata[names[index]] = fields[index]
	}

	// Assign the key type
	if keyType, ok := metadata["type"]; ok {
		meta.Type = keyType
	}

	// Assign the uid
	if uid, ok := metadata["uid"]; ok {
		if converted, err := strconv.Atoi(uid); err == nil {
			meta.Uid = converted
		}
	}

	// Assign the gid
	if gid, ok := metadata["gid"]; ok {
		if converted, err := strconv.Atoi(gid); err == nil {
			meta.Gid = converted
		}
	}

	// Assign the Name
	if name, ok := metadata["name"]; ok {
		meta.Name = name
	}

	// Assign the permissions
	if perm, ok := metadata["perm"]; ok {
		n := new(big.Int)
		n.SetString(perm, 16)
		meta.Permissions = KeyPerm(n.Uint64())
	}

	return meta, nil
}

// =================================================================
// Keyring

// addKeyring creates a new keyring with a specific name and return its id
func addKeyring(name string, keyringId Serial) (int, error) {
	id, err := unix.AddKey(KEY_TYPE_KEYRING, name, nil, keyringId.Int())

	// Convert the error
	err = fromErr(err)

	return id, err
}

func getKeyringId(name string, keyringId Serial) (Serial, error) {
	key, err := unix.KeyctlSearch(keyringId.Int(), KEY_TYPE_KEYRING, name, 0)

	// Convert the error
	err = fromErr(err)

	return Serial(key), err
}

// Sets the key/keyring id permissions
func setPermissions(keyringId Serial, permissions uint32) error {
	return unix.KeyctlSetperm(keyringId.Int(), permissions)
}

// Deletes a keyring
func deleteKeyring(keyringId Serial, parentKeyringId Serial) error {

	// Clear all the keys
	syscall.Syscall(syscall.SYS_KEYCTL, uintptr(unix.KEYCTL_CLEAR), uintptr(keyringId.Int()), 0)

	// Unlink it
	_, _, errno := syscall.Syscall(syscall.SYS_KEYCTL, uintptr(unix.KEYCTL_UNLINK), uintptr(keyringId.Int()), uintptr(parentKeyringId.Int()))

	// If the errno is zero then we are good
	if errno != 0 {
		// Convert the error
		err := fromErr(errno)
		return err
	}

	return nil
}
